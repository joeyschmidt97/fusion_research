import os
import numpy as np

from GENE_sim_reader.src.dict_simulation_data import sim_filepath_to_df
from GENE_sim_reader.src.dict_parameters_data import parameters_filepath_to_dict, create_species_tuple



def MTM_dataframe(filepath):

    spec_name = 'e'
    criteria = ['time==last', 'Q_ES', 'Q_EM']

    sim_df = sim_filepath_to_df(filepath_list=filepath, criteria_list=criteria, load_spec=spec_name)
    sim_df = get_reference_values(sim_df, spec_name) # get reference values for beta, coll, and omt2

    # calculate distance from reference values
    sim_df['dist_coll'] = sim_df['coll'] - sim_df['ref_coll']
    sim_df['dist_beta'] = sim_df['beta'] - sim_df['ref_beta']
    sim_df['dist_omt2'] = sim_df['omt2'] - sim_df['ref_omt2']
    
    # calculate percent difference from reference values
    sim_df['pd_coll'] = (sim_df['coll'] - sim_df['ref_coll'])/sim_df['ref_coll']
    sim_df['pd_beta'] = (sim_df['beta'] - sim_df['ref_beta'])/sim_df['ref_beta']
    sim_df['pd_omt2'] = (sim_df['omt2'] - sim_df['ref_omt2'])/sim_df['ref_omt2']

    # find 3D euclidean distance from reference point generated by GENE
    sim_df['euclidean_dist'] = (sim_df['dist_coll']**2 + sim_df['dist_beta']**2 + sim_df['dist_omt2']**2)**0.5
    sim_df['euclidean_dist'] = round_close_numbers(sim_df['euclidean_dist'].values)

    # Add normalized Q_EM/Q_ES ratio (note if ratio > 0.5 it is electromagnetically dominant)
    Q_EM = sim_df['Q_EM2']
    Q_ES = sim_df['Q_ES2']
    norm_Q_ratio = Q_EM/(Q_EM + Q_ES)
    sim_df['norm_Q_ratio'] = norm_Q_ratio

    return sim_df
    



# Define a function to round close numbers
def round_close_numbers(arr, precision=1e-8):
    unique_numbers = np.unique(arr)
    
    for num in unique_numbers:
        close_indices = np.isclose(arr, num, atol=precision)
        arr[close_indices] = num

    return arr





def get_reference_values(sim_df, spec_name):

    unique_directories = sim_df['directory'].unique()

    for dir_filepath in unique_directories:
        input_param_filepath = os.path.join(dir_filepath, 'parameters')
        ref_param_dict = parameters_filepath_to_dict(input_param_filepath)

        spec_tuple, _ = sim_df.loc[sim_df['directory'] == dir_filepath, 'species_info'].iloc[0]
        
        for (name, num) in spec_tuple:
            if name==spec_name:
                spec_num = num
                break
            
        # Extract the float values associated with these keys
        ref_coll = extract_value_from_string(ref_param_dict['coll'])
        ref_beta = extract_value_from_string(ref_param_dict['beta'])
        omt_name = 'omt'+ str(spec_num)
        ref_omt = extract_value_from_string(ref_param_dict[omt_name])

        sim_df.loc[sim_df['directory'] == dir_filepath, 'ref_coll'] = ref_coll
        sim_df.loc[sim_df['directory'] == dir_filepath, 'ref_beta'] = ref_beta
        sim_df.loc[sim_df['directory'] == dir_filepath, 'ref_' + omt_name] = ref_omt

    return sim_df




def extract_value_from_string(value_str: str) -> float:
    """
    Extract float value from a string based on the predefined format.
    Args:
    - value_str (str): The input string, e.g., "value=123.45  !scan:123.45*perc(0)"
    Returns:
    - float: Extracted float value from the string.
    """
    # Split the string by '!scan:', take the last part, then split by '*' and take the first part, and finally strip to convert to float
    
    return float(value_str.split('!scan:')[-1].split('*')[0].strip())










